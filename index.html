<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <script src="//cdn.jsdelivr.net/npm/phaser@3.16.2/dist/phaser.js"></script>
    <title>Document</title>
  </head>
  <body>
    <script>
      var config = {
        type: Phaser.AUTO,
        parent: "phaser-example",
        width: 800,
        height: 600,
        physics: {
          default: "arcade",
          arcade: {
            fps: 60,
            gravity: { y: 0 }
          }
        },
        scene: {
          preload: preload,
          create: create,
          update: update
        }
      };

      var game = new Phaser.Game(config);

      function preload() {
        this.load.setBaseURL("http://labs.phaser.io");

        this.load.image("ship", "assets/games/asteroids/ship.png");
        this.load.image("arrow", "assets/sprites/arrow.png");
        this.load.image("bullet", "assets/sprites/purple_ball.png");
      }

      var naveManual;
      var naveAgente;
      var cursors;
      var maxVelocity = 200;

      function create() {
        naveManual = this.physics.add.image(800, 300, "ship");
        naveManual.setDamping(true);
        naveManual.setDrag(0.99);
        naveManual.setMaxVelocity(maxVelocity);
        //console.log(naveManual.debugShowVelocity);
        naveManual.setCollideWorldBounds(true);

        naveAgente = this.physics.add.image(300, 300, "ship");
        naveAgente.setDamping(true);
        naveAgente.setDrag(0.99);
        naveAgente.setMaxVelocity(maxVelocity);
        naveAgente.setCollideWorldBounds(true);

        cursors = this.input.keyboard.createCursorKeys();
      }

      function update() {
        //Actualizamos la nave manejada por el usuario
        if (cursors.up.isDown) {
          this.physics.velocityFromRotation(
            naveManual.rotation,
            maxVelocity,
            naveManual.body.acceleration
          );
        } else {
          naveManual.setAcceleration(0);
        }

        if (cursors.left.isDown) {
          naveManual.setAngularVelocity(-300);
        } else if (cursors.right.isDown) {
          naveManual.setAngularVelocity(300);
        } else {
          naveManual.setAngularVelocity(0);
        }

        //seek(naveAgente, naveManual);
        //flee(naveAgente, naveManual);
        //arrive(naveAgente, naveManual);
        wander(naveAgente);

        /*
              var alignment = computeAlignment(naveAgente, [naveManual]);
              var cohesion = computeCohesion(naveAgente, [naveManual]);
              var separation = computeSeparation(naveAgente, [naveManual]);
              var aux = alignment.add(cohesion.add(separation));
              aux.scale(100);
              naveAgente.setVelocity(aux.x, aux.y);
              var angle = naveAgente.body.velocity.angle();
              naveAgente.rotation = angle;
              naveAgente.body.world.scene.physics.velocityFromRotation(
                angle,
                naveAgente.body.velocity.length(),
                naveAgente.body.velocity
              );
              console.log(naveAgente.body.velocity);*/

        //this.physics.world.wrap(naveManual, 0);
        //this.physics.world.wrap(naveAgente, 0);
      }

      function seek(pVehicle, pTarget) {
        var vectorDesired;
        // 1. vector(desired velocity) = (target position) - (vehicle position)
        vectorDesired = pTarget.body.position.subtract(pVehicle.body.position);
        // 2. normalize vector(desired velocity)
        vectorDesired.normalize();
        // 3. scale vector(desired velocity) to maximum speed
        vectorDesired.scale(maxVelocity);
        // 4. vector(steering force) = vector(desired velocity) - vector(current velocity)
        var vectorSteering = vectorDesired.subtract(pVehicle.body.velocity);
        // 5. limit the magnitude of vector(steering force) to maximum force
        //vectorSteering.scale(200);
        // 6. vector(new velocity) = vector(current velocity) + vector(steering force)
        truncate(vectorSteering.add(pVehicle.body.velocity), maxVelocity);
        pVehicle.setVelocity(vectorSteering.x, vectorSteering.y);
        // 7. limit the magnitude of vector(new velocity) to maximum speed
        //pVehicle.body.velocity.scale(200);
        // 8. update vehicle rotation according to the angle of the vehicle velocity

        var angle = pVehicle.body.velocity.angle();
        //const angle = Phaser.Math.DegToRad(pVehicle.body.rotation - 90);

        pVehicle.rotation = angle;
        pVehicle.body.world.scene.physics.velocityFromRotation(
          angle,
          pVehicle.body.velocity.length(),
          pVehicle.body.velocity
        );
      }

      function flee(pVehicle, pTarget) {
        var vectorDesired;
        // 1. vector(desired velocity) = (target position) - (vehicle position)
        vectorDesired = pTarget.body.position.subtract(pVehicle.body.position);
        // 2. normalize vector(desired velocity)
        vectorDesired.normalize();
        // 3. scale vector(desired velocity) to maximum speed
        vectorDesired.scale(maxVelocity);
        // 4. negate seek vector
        vectorDesired.negate();
        // 5. vector(steering force) = vector(desired velocity) - vector(current velocity)
        var vectorSteering = vectorDesired.subtract(pVehicle.body.velocity);

        // 6. limit the magnitude of vector(steering force) to maximum force
        //vectorSteering.scale(200);
        // 7. vector(new velocity) = vector(current velocity) + vector(steering force)
        pVehicle.setVelocity(vectorSteering.x, vectorSteering.y);
        // 8. limit the magnitude of vector(new velocity) to maximum speed
        //pVehicle.body.velocity.scale(200);
        // 9. update vehicle rotation according to the angle of the vehicle velocity

        var angle = pVehicle.body.velocity.angle();
        //const angle = Phaser.Math.DegToRad(pVehicle.body.rotation - 90);

        pVehicle.rotation = angle;
        pVehicle.body.world.scene.physics.velocityFromRotation(
          angle,
          pVehicle.speed,
          pVehicle.body.velocity
        );
      }

      function arrive(pVehicle, pTarget) {
        var vectorDesired;
        var distanceToTarget;
        var slowingRadius = 400;
        // 1. vector(desired velocity) = (target position) - (vehicle position)
        vectorDesired = pTarget.body.position.subtract(pVehicle.body.position);

        distanceToTarget = vectorDesired.length();

        if (distanceToTarget < slowingRadius) {
          vectorDesired
            .normalize()
            .scale(maxVelocity)
            .scale(distanceToTarget / slowingRadius);
        } else {
          vectorDesired.normalize().scale(maxVelocity);
        }

        // 5. vector(steering force) = vector(desired velocity) - vector(current velocity)
        var vectorSteering = vectorDesired.subtract(pVehicle.body.velocity);

        // 6. limit the magnitude of vector(steering force) to maximum force
        //vectorSteering.scale(200);
        // 7. vector(new velocity) = vector(current velocity) + vector(steering force)
        truncate(vectorSteering.add(pVehicle.body.velocity), maxVelocity);
        pVehicle.setVelocity(vectorSteering.x, vectorSteering.y);
        // 8. limit the magnitude of vector(new velocity) to maximum speed
        //pVehicle.body.velocity.scale(200);
        // 9. update vehicle rotation according to the angle of the vehicle velocity

        var angle = pVehicle.body.velocity.angle();
        //const angle = Phaser.Math.DegToRad(pVehicle.body.rotation - 90);

        pVehicle.rotation = angle;
        pVehicle.body.world.scene.physics.velocityFromRotation(
          angle,
          pVehicle.body.velocity.length(),
          pVehicle.body.velocity
        );
      }

      function wander(pVehicle) {
        const CIRCLE_DISTANCE = 150; // Distancia desde la nave hasta el centro del circulo
        const CIRCLE_RADIUS = 15; // Radio del circulo
        const ANGLE_CHANGE = 15;
        var circleCenter = pVehicle.body.velocity
          .clone()
          .normalize()
          .scale(CIRCLE_DISTANCE);

        //console.log("circleCenter");
        //console.log(circleCenter);

        var xInicial = Math.random() < 0.5 ? 0 : 1;
        var yInicial = Math.random() < 0.5 ? 0 : 1;

        var displacement = new Phaser.Math.Vector2(1, 1);
        displacement.scale(CIRCLE_RADIUS);

        var wanderAngle = 0;
        wanderAngle += Math.random() * ANGLE_CHANGE - ANGLE_CHANGE * 0.5;
        setAngle(displacement, wanderAngle);

        //console.log(wanderAngle);
        //console.log(displacement);

        var wanderForce = circleCenter.add(displacement);

        //console.log(wanderForce);

        truncate(wanderForce, maxVelocity);
        pVehicle.setVelocity(wanderForce.x, wanderForce.y);

        var angle = pVehicle.body.velocity.angle();

        pVehicle.rotation = angle;
        pVehicle.body.world.scene.physics.velocityFromRotation(
          angle,
          pVehicle.body.velocity.length(),
          pVehicle.body.velocity
        );
      }

      function setAngle(vector, value) {
        var len = vector.length();
        vector.x = Math.cos(value) * len;
        vector.y = Math.sin(value) * len;
      }

      function truncate(vector, max) {
        var i;
        i = max / vector.length();
        if (i > 1.0) {
          i = 1.0;
        }
        vector.scale(i);
      }

      function computeAlignment(miAgente, agentes) {
        //console.log(lider);
        //console.log(agentes);
        var vectorAlignment = new Phaser.Math.Vector2(0, 0);
        var vecinos = 0;
        for (var agente of agentes) {
          if (agente != miAgente) {
            var vectorDistancia = miAgente.body.position.subtract(
              agente.body.position
            );
            distanceToTarget = vectorDistancia.length();
            //console.log(distanceToTarget);
            if (distanceToTarget < 300) {
              vectorAlignment.x += agente.body.velocity.x;
              vectorAlignment.y += agente.body.velocity.y;
              vecinos++;
            }
          }
        }
        if (vecinos == 0) {
          return vectorAlignment;
        }

        //console.log(vectorAlignment);
        vectorAlignment.x /= vecinos;
        vectorAlignment.y /= vecinos;
        vectorAlignment.normalize();

        return vectorAlignment;
      }

      function computeCohesion(miAgente, agentes) {
        var vectorAlignment = new Phaser.Math.Vector2(0, 0);
        var vecinos = 0;
        for (var agente of agentes) {
          if (agente != miAgente) {
            var vectorDistancia = miAgente.body.position.subtract(
              agente.body.position
            );
            distanceToTarget = vectorDistancia.length();
            if (distanceToTarget < 300) {
              vectorAlignment.x += agente.body.x;
              vectorAlignment.y += agente.body.y;
              vecinos++;
            }
          }
        }
        if (vecinos == 0) {
          return vectorAlignment;
        }

        vectorAlignment.x /= vecinos;
        vectorAlignment.y /= vecinos;
        vectorAlignment = new Phaser.Math.Vector2(
          vectorAlignment.x - miAgente.body.x,
          vectorAlignment.y - miAgente.body.y
        );
        vectorAlignment.normalize();
        return vectorAlignment;
      }

      function computeSeparation(miAgente, agentes) {
        var vectorAlignment = new Phaser.Math.Vector2(0, 0);
        var vecinos = 0;
        for (var agente of agentes) {
          if (agente != miAgente) {
            var vectorDistancia = miAgente.body.position.subtract(
              agente.body.position
            );
            distanceToTarget = vectorDistancia.length();
            if (distanceToTarget < 300) {
              vectorAlignment.x += agente.body.x - miAgente.body.x;
              vectorAlignment.y += agente.body.y - miAgente.body.y;
              vecinos++;
            }
          }
        }
        if (vecinos == 0) {
          return vectorAlignment;
        }

        vectorAlignment.x /= vecinos;
        vectorAlignment.y /= vecinos;
        vectorAlignment.negate();
        vectorAlignment.normalize();
        return vectorAlignment;
      }
    </script>
  </body>
</html>
