<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <script src="//cdn.jsdelivr.net/npm/phaser@3.16.2/dist/phaser.js"></script>
    <title>Document</title>
  </head>
  <body>
    <script>
      var config = {
        type: Phaser.AUTO,
        parent: "phaser-example",
        width: 800,
        height: 600,
        physics: {
          default: "arcade",
          arcade: {
            fps: 60,
            gravity: { y: 0 }
          }
        },
        scene: {
          preload: preload,
          create: create,
          update: update
        }
      };

      var game = new Phaser.Game(config);

      function preload() {
        this.load.setBaseURL("http://labs.phaser.io");

        this.load.image("ship", "assets/games/asteroids/ship.png");
        this.load.image("arrow", "assets/sprites/arrow.png");
        this.load.image("bullet", "assets/sprites/purple_ball.png");
      }

      var targetShip;
      var seekingShip;
      var cursors;
      var maxVelocity = 200;

      function create() {
        targetShip = this.physics.add.image(800, 300, "ship");
        targetShip.setDamping(true);
        targetShip.setDrag(0.99);
        targetShip.setMaxVelocity(maxVelocity);
        //console.log(targetShip.debugShowVelocity);
        targetShip.setCollideWorldBounds(true);

        seekingShip = this.physics.add.image(0, 300, "ship");
        seekingShip.setDamping(true);
        seekingShip.setDrag(0.99);
        seekingShip.setMaxVelocity(maxVelocity);
        seekingShip.setCollideWorldBounds(true);

        cursors = this.input.keyboard.createCursorKeys();
      }

      function update() {
        //console.log(targetShip.body.velocity);
        if (cursors.up.isDown) {
          this.physics.velocityFromRotation(
            targetShip.rotation,
            maxVelocity,
            targetShip.body.acceleration
          );
        } else {
          targetShip.setAcceleration(0);
        }

        if (cursors.left.isDown) {
          targetShip.setAngularVelocity(-300);
        } else if (cursors.right.isDown) {
          targetShip.setAngularVelocity(300);
        } else {
          targetShip.setAngularVelocity(0);
        }

        //seek(seekingShip, targetShip);
        //flee(seekingShip, targetShip);
        arrive(seekingShip, targetShip);

        //text.setText("Speed: " + targetShip.body.speed);

        //this.physics.world.wrap(targetShip, 0);
        //this.physics.world.wrap(seekingShip, 0);
      }

      function seek(pVehicle, pTarget) {
        var vectorDesired;
        // 1. vector(desired velocity) = (target position) - (vehicle position)
        vectorDesired = pTarget.body.position.subtract(pVehicle.body.position);
        // 2. normalize vector(desired velocity)
        vectorDesired.normalize();
        // 3. scale vector(desired velocity) to maximum speed
        vectorDesired.scale(maxVelocity);
        // 4. vector(steering force) = vector(desired velocity) - vector(current velocity)
        var vectorSteering = vectorDesired.subtract(pVehicle.body.velocity);
        // 5. limit the magnitude of vector(steering force) to maximum force
        //vectorSteering.scale(200);
        // 6. vector(new velocity) = vector(current velocity) + vector(steering force)
        truncate(vectorSteering.add(pVehicle.body.velocity), maxVelocity);
        pVehicle.setVelocity(vectorSteering.x, vectorSteering.y);
        // 7. limit the magnitude of vector(new velocity) to maximum speed
        //pVehicle.body.velocity.scale(200);
        // 8. update vehicle rotation according to the angle of the vehicle velocity

        var angle = pVehicle.body.velocity.angle();
        //const angle = Phaser.Math.DegToRad(pVehicle.body.rotation - 90);

        pVehicle.rotation = angle;
        pVehicle.body.world.scene.physics.velocityFromRotation(
          angle,
          pVehicle.body.velocity.length(),
          pVehicle.body.velocity
        );
      }

      function flee(pVehicle, pTarget) {
        var vectorDesired;
        // 1. vector(desired velocity) = (target position) - (vehicle position)
        vectorDesired = pTarget.body.position.subtract(pVehicle.body.position);
        // 2. normalize vector(desired velocity)
        vectorDesired.normalize();
        // 3. scale vector(desired velocity) to maximum speed
        vectorDesired.scale(maxVelocity);
        // 4. negate seek vector
        vectorDesired.negate();
        // 5. vector(steering force) = vector(desired velocity) - vector(current velocity)
        var vectorSteering = vectorDesired.subtract(pVehicle.body.velocity);

        // 6. limit the magnitude of vector(steering force) to maximum force
        //vectorSteering.scale(200);
        // 7. vector(new velocity) = vector(current velocity) + vector(steering force)
        pVehicle.setVelocity(vectorSteering.x, vectorSteering.y);
        // 8. limit the magnitude of vector(new velocity) to maximum speed
        //pVehicle.body.velocity.scale(200);
        // 9. update vehicle rotation according to the angle of the vehicle velocity

        var angle = pVehicle.body.velocity.angle();
        //const angle = Phaser.Math.DegToRad(pVehicle.body.rotation - 90);

        pVehicle.rotation = angle;
        pVehicle.body.world.scene.physics.velocityFromRotation(
          angle,
          pVehicle.speed,
          pVehicle.body.velocity
        );
      }

      function arrive(pVehicle, pTarget) {
        var vectorDesired;
        var distanceToTarget;
        var slowingRadius = 400;
        // 1. vector(desired velocity) = (target position) - (vehicle position)
        vectorDesired = pTarget.body.position.subtract(pVehicle.body.position);

        distanceToTarget = vectorDesired.length();

        if (distanceToTarget < slowingRadius) {
          vectorDesired
            .normalize()
            .scale(maxVelocity)
            .scale(distanceToTarget / slowingRadius);
        } else {
          vectorDesired.normalize().scale(maxVelocity);
        }

        // 5. vector(steering force) = vector(desired velocity) - vector(current velocity)
        var vectorSteering = vectorDesired.subtract(pVehicle.body.velocity);

        // 6. limit the magnitude of vector(steering force) to maximum force
        //vectorSteering.scale(200);
        // 7. vector(new velocity) = vector(current velocity) + vector(steering force)
        truncate(vectorSteering.add(pVehicle.body.velocity), maxVelocity);
        pVehicle.setVelocity(vectorSteering.x, vectorSteering.y);
        // 8. limit the magnitude of vector(new velocity) to maximum speed
        //pVehicle.body.velocity.scale(200);
        // 9. update vehicle rotation according to the angle of the vehicle velocity

        var angle = pVehicle.body.velocity.angle();
        //const angle = Phaser.Math.DegToRad(pVehicle.body.rotation - 90);

        pVehicle.rotation = angle;
        pVehicle.body.world.scene.physics.velocityFromRotation(
          angle,
          pVehicle.body.velocity.length(),
          pVehicle.body.velocity
        );
      }

      function truncate(vector, max) {
        var i;
        i = max / vector.length();
        if (i > 1.0) {
          i = 1.0;
        }
        vector.scale(i);
      }
    </script>
  </body>
</html>
